const { createChatObject } = require("../utils");

module.exports = {
  generateRawLyrics,
};

/**
 * Generates raw lyrics based on a specified meter and prompts.
 *
 * @async
 * @function generateRawLyrics
 * @param {Object} options - The options for generating the lyrics.
 * @param {number} options.lineLimit - The maximum number of lines for the generated lyrics.
 * @param {Array<Array<number>>} options.meter - The meter pattern for the lyrics, an array of arrays of numbers.
 * @param {string} options.selectedUserPrompt - The key for the selected user prompt.
 * @param {string} options.selectedSystemPrompt - The key for the selected system prompt.
 * @param {string} options.restOfSong - The rest of the song lyrics.
 * @param {string} options.customSystemPrompt - A custom system prompt.
 * @param {string} options.songTitle - The title of the song.
 * @param {string} options.songDescription - A description of the song.
 * @param {string} [options.clientChoice="anthropic"] - The choice of AI client.
 * @returns {Promise<Array<string>>} The raw lyrics generated by the AI API.
 * @throws Will log an error to the console if the API call fails.
 */
async function generateRawLyrics({
  lineLimit,
  meter,
  selectedUserPrompt,
  selectedSystemPrompt,
  restOfSong,
  customSystemPrompt,
  songTitle,
  songDescription,
  clientChoice = "anthropic",
}) {
  try {
    const meterString = meter
      .map(
        (pattern, index) =>
          `Line ${
            index + 1
          } will use this pattern: ${pattern.join()} and have ${
            pattern.length
          } syllables.`
      )
      .join(" ");

    const alternatingInstructions =
      meter.length > 0
        ? "Make sure to use this alternating meter pattern: "
        : "";
    const finalString = alternatingInstructions + meterString;
    const chatCompletion = await createChatObject({
      clientChoice,
      customSystemPrompt,
      selectedSystemPrompt,
      selectedUserPrompt,
      lineLimit,
      finalString,
      restOfSong,
      songTitle,
      songDescription,
    });

    switch (clientChoice) {
      case "llama":
        let llamaOutput = "";

        for await (const event of chatCompletion) {
          llamaOutput += event.toString();
        }

        return llamaOutput
          .split("\n")
          .filter((e) => e.length > 0)
          .map((e) => e.trim());

      case "openai":
        return chatCompletion.choices[0].message.content
          .split("\n")
          .filter((e) => e.length > 0)
          .map((e) => {
            const newStr = e
              .split(" ")
              .map((e) => e.replace(/\d/g, "").trim())
              .filter((e) => e.length > 0)
              .join(" ");

            return newStr.trim();
          });

      case "anthropic":
      default:
        return chatCompletion.content[0].text
          .split("\n")
          .filter((e) => e.length > 0)
          .map((e) => e.trim());
    }
  } catch (err) {
    console.log(err);
    throw err; // Re-throw the error after logging
  }
}
